<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P File Sharer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PeerJS library for WebRTC -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* Custom font and minor style adjustments */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the progress bar */
        .progress-bar-inner {
            transition: width 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto">
        <div class="bg-gray-800 shadow-2xl rounded-2xl p-6 md:p-8">
            <div class="text-center mb-6">
                <h1 class="text-3xl font-bold text-cyan-400">P2P FileDrop</h1>
                <p class="text-gray-400 mt-2">Share files directly with a peer, browser to browser.</p>
            </div>

            <!-- Connection Section -->
            <div class="space-y-4 mb-6">
                <div>
                    <label for="my-id" class="block text-sm font-medium text-gray-300 mb-1">Your ID</label>
                    <div class="flex items-center bg-gray-700 rounded-lg p-2">
                        <input type="text" id="my-id" readonly class="flex-grow bg-transparent text-gray-200 focus:outline-none">
                        <button id="copy-id-btn" class="ml-2 bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-1 px-3 rounded-md text-sm">Copy</button>
                    </div>
                </div>
                <div>
                    <label for="peer-id" class="block text-sm font-medium text-gray-300 mb-1">Peer's ID</label>
                    <div class="flex space-x-2">
                        <input type="text" id="peer-id" placeholder="Enter peer's ID to connect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500">
                        <button id="connect-btn" class="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg">Connect</button>
                    </div>
                </div>
            </div>

            <!-- Status Section -->
            <div id="status" class="text-center text-gray-400 mb-6 h-6"></div>

            <!-- File Sharing Section -->
            <div id="file-sharing-section" class="hidden space-y-4">
                 <div>
                    <label for="file-input" class="block text-sm font-medium text-gray-300 mb-2">Select a file to send</label>
                    <input type="file" id="file-input" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-cyan-600 file:text-white hover:file:bg-cyan-700">
                </div>
                <button id="send-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg disabled:bg-gray-500 disabled:cursor-not-allowed" disabled>Send File</button>
            </div>
            
            <!-- Progress and Download Section -->
            <div id="progress-container" class="hidden w-full bg-gray-700 rounded-full h-2.5 mt-4">
                <div id="progress-bar" class="bg-cyan-500 h-2.5 rounded-full progress-bar-inner" style="width: 0%"></div>
            </div>
            <div id="download-section" class="text-center mt-4"></div>

        </div>
        <footer class="text-center text-gray-500 text-xs mt-4">
            <p>Powered by WebRTC & PeerJS</p>
        </footer>
    </div>

    <script>
        // DOM Element References
        const myIdEl = document.getElementById('my-id');
        const copyIdBtn = document.getElementById('copy-id-btn');
        const peerIdInput = document.getElementById('peer-id');
        const connectBtn = document.getElementById('connect-btn');
        const statusEl = document.getElementById('status');
        const fileSharingSection = document.getElementById('file-sharing-section');
        const fileInput = document.getElementById('file-input');
        const sendBtn = document.getElementById('send-btn');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const downloadSection = document.getElementById('download-section');

        // Global variables
        let peer = null;
        let conn = null;
        let fileToSend = null;
        const CHUNK_SIZE = 16384; // 16KB chunk size, optimal for WebRTC data channels

        /**
         * Initializes the Peer object and sets up event listeners.
         * This function is called when the page loads.
         */
        function initializePeer() {
            // Create a new Peer object. Passing no ID will cause the server to generate one.
            // Using a public PeerJS server. For production, you'd host your own.
            peer = new Peer({
                host: 'peerjs-server.fly.dev',
                secure: true,
                port: 443
            });

            // --- PEER EVENT LISTENERS ---

            // Fired when the peer has connected to the PeerServer.
            peer.on('open', (id) => {
                myIdEl.value = id;
                statusEl.textContent = 'Ready to connect.';
            });

            // Fired when a remote peer attempts to connect.
            peer.on('connection', (newConn) => {
                setupConnection(newConn);
                statusEl.textContent = `Connected to ${newConn.peer}`;
                peerIdInput.value = newConn.peer;
            });

            // Fired when the peer is disconnected from the signaling server.
            peer.on('disconnected', () => {
                statusEl.textContent = 'Disconnected. Please refresh.';
                // You might want to attempt to reconnect here
            });

            // Fired when an error occurs.
            peer.on('error', (err) => {
                console.error(err);
                statusEl.textContent = `Error: ${err.message}`;
                alert(`An error occurred: ${err.type}`);
            });
        }

        /**
         * Sets up the data connection event listeners for both sender and receiver.
         * @param {DataConnection} connection - The PeerJS DataConnection object.
         */
        function setupConnection(connection) {
            conn = connection;
            
            // Clean up previous connections if any
            conn.on('close', handleDisconnect);
            conn.on('error', (err) => console.error('Connection error:', err));
            
            // --- CONNECTION EVENT LISTENERS ---
            
            // Fired when the connection is established and ready for data.
            conn.on('open', () => {
                statusEl.textContent = `Connected to ${conn.peer}`;
                fileSharingSection.classList.remove('hidden');
                connectBtn.disabled = true;
                peerIdInput.disabled = true;
            });

            // Fired when data is received from the remote peer.
            let receivedFileChunks = [];
            let fileMetadata = {};

            conn.on('data', (data) => {
                // The data can be either file metadata or a file chunk
                if (data.type === 'metadata') {
                    fileMetadata = data.payload;
                    receivedFileChunks = []; // Reset for new file
                    downloadSection.innerHTML = ''; // Clear previous download links
                    progressContainer.classList.remove('hidden');
                    progressBar.style.width = '0%';
                    statusEl.textContent = `Receiving file: ${fileMetadata.name}`;
                } else if (data.type === 'chunk') {
                    receivedFileChunks.push(data.payload);
                    const progress = (receivedFileChunks.length * CHUNK_SIZE) / fileMetadata.size * 100;
                    progressBar.style.width = `${Math.min(progress, 100)}%`;
                } else if (data.type === 'end') {
                    statusEl.textContent = 'File received successfully!';
                    createDownloadLink(receivedFileChunks, fileMetadata);
                    receivedFileChunks = []; // Clear memory
                }
            });
        }

        /**
         * Combines received file chunks into a Blob and creates a downloadable link.
         * @param {ArrayBuffer[]} chunks - The array of file chunks.
         * @param {object} metadata - The file metadata (name, type).
         */
        function createDownloadLink(chunks, metadata) {
            const fileBlob = new Blob(chunks, { type: metadata.type });
            const url = URL.createObjectURL(fileBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = metadata.name;
            link.innerHTML = `Download ${metadata.name}`;
            link.className = 'inline-block bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg';
            
            downloadSection.innerHTML = ''; // Clear previous links
            downloadSection.appendChild(link);
        }

        /**
         * Handles the file sending process.
         */
        function sendFile() {
            if (!fileToSend || !conn) {
                alert('Please select a file and ensure you are connected.');
                return;
            }

            statusEl.textContent = `Sending file: ${fileToSend.name}`;
            progressContainer.classList.remove('hidden');
            progressBar.style.width = '0%';

            // 1. Send metadata first
            conn.send({
                type: 'metadata',
                payload: {
                    name: fileToSend.name,
                    size: fileToSend.size,
                    type: fileToSend.type
                }
            });

            // 2. Read and send file in chunks
            const reader = new FileReader();
            let offset = 0;

            reader.onload = (event) => {
                if (!event.target.error) {
                    conn.send({ type: 'chunk', payload: event.target.result });
                    offset += event.target.result.byteLength;
                    
                    // Update progress bar
                    const progress = (offset / fileToSend.size) * 100;
                    progressBar.style.width = `${progress}%`;

                    if (offset < fileToSend.size) {
                        readSlice(offset); // Read the next chunk
                    } else {
                        conn.send({ type: 'end' }); // Signal end of file
                        statusEl.textContent = 'File sent successfully!';
                    }
                } else {
                    console.error('File Read Error:', event.target.error);
                    statusEl.textContent = 'Error reading file.';
                }
            };
            
            const readSlice = (o) => {
                const slice = fileToSend.slice(o, o + CHUNK_SIZE);
                reader.readAsArrayBuffer(slice);
            };

            readSlice(0); // Start reading the first chunk
        }

        /**
         * Handles the disconnection of a peer.
         */
        function handleDisconnect() {
            statusEl.textContent = 'Peer has disconnected.';
            conn = null;
            fileSharingSection.classList.add('hidden');
            progressContainer.classList.add('hidden');
            downloadSection.innerHTML = '';
            connectBtn.disabled = false;
            peerIdInput.disabled = false;
        }

        // --- EVENT LISTENERS FOR UI ELEMENTS ---

        // Connect button
        connectBtn.addEventListener('click', () => {
            const peerId = peerIdInput.value.trim();
            if (!peerId) {
                alert('Please enter a peer ID.');
                return;
            }
            if (peer) {
                statusEl.textContent = `Connecting to ${peerId}...`;
                const newConn = peer.connect(peerId, { reliable: true });
                setupConnection(newConn);
            }
        });
        
        // File input change
        fileInput.addEventListener('change', (event) => {
            fileToSend = event.target.files[0];
            if (fileToSend) {
                sendBtn.disabled = false;
            } else {
                sendBtn.disabled = true;
            }
        });

        // Send button
        sendBtn.addEventListener('click', sendFile);

        // Copy ID button
        copyIdBtn.addEventListener('click', () => {
            myIdEl.select();
            document.execCommand('copy');
            statusEl.textContent = 'Your ID has been copied to the clipboard!';
            setTimeout(() => {
                if (conn) {
                     statusEl.textContent = `Connected to ${conn.peer}`;
                } else {
                     statusEl.textContent = 'Ready to connect.';
                }
            }, 2000);
        });

        // Initialize the application
        initializePeer();
    </script>
</body>
</html>
